"use strict";
// Переменные, созданные с использованием ключевого слова var, находятся
// либо в ГЛОБАЛЬНОЙ области видимости
// либо в ЛОКАЛЬНОЙ области видимости, которая представлена функцией, НО НЕ В БЛОЧНОЙ.
// При этом переменная доступна до ее фактически определения в коде функции и после любого блока {}
// не повлияет на код ниже потому, что в области видимости уже есть объявление переменной i.
// т.е внутри функции var1 переменаая  i  существует, но кодом ниже.
var i = 10;
function var1() {
    // если // "strictNullChecks": true, то тут будут ошибки
    // @ts-ignore
    console.log(i); // undefined
    // @ts-ignore
    console.log(test); //indefined
    for (var i = 0; i < 10; i++) {
        var test = i;
    }
    console.log(i); // 10
    // @ts-ignore
    console.log(test); //9
}
var1();
// Повторное определние переменной не приводит к ошибке
// @ts-ignore
function var2() {
    var a = 10;
    var a = 20;
    console.log(a); // 20
}
var2();
// Такой цикл выведет на экран 5, 5, 5, 5, 5 вместо ожидаемых 0, 1, 2, 3, 4,
// Каждый раз, когда вызывалась функция setTimeOut, ей передавались ссылка НА ОДНУ И ТУ ЖЕ ПЕРЕМЕННУЮ
// из области видимости f3, по этому все вызовы setTimeout в итоге ССЫЛАЛИСЬ НА ОДНО ЗНАЧЕНИЕ.
// @ts-ignore
function var3() {
    // так, как переменная одна, а цикл у нас сыполняется с задержкой, то
    // счетчик быстренько приймет значение 5 и во все вызовы setTimeout будет передаваться значение 5.
    // а при использовании let - каждый раз создается своя зона видимости. Смотри следующий пример.
    for (var i = 0; i < 5; i++) {
        setTimeout(function () { console.log(i); }, 10);
    }
}
var3();
//# sourceMappingURL=02-var-scoping.js.map